---
tags:
  - Cpp
---
Linking is the second step of the build process. Whille the compilation is handled by the compiler, linking is handled by the linker. Effectibvely, what it does is look for function/symbol headers in your code and tries to link them to the declaration of such symbols. Therefore it "stitches" the multiple .obj generated by the compiler together  and makes sure everything needed at runtime is properly declared.
Heed the following example:
```cpp
#This is a file called Log.cpp
#include <iostream> ; i need iostream to use cout
void Log(const char* msg){
	std::cout << "This is msg" << std::endl();
}
#This is a header file called Log.h
void Log(const char*);
#This is the main entry point for our application , Main.cpp
#include <iostream>
#include "Log.h"

int main(){
	Log("Hello World");
}
```
This is how the majority of C++ or even C projects will be structured , a header File which contains function declarations , a translation unit(file) that contains their declaration and a main file where they are used. It is said that only the main file is client-side.
Here a few things are happening:
- When I use the \#include keyword in my main file, I'm simply pasting the contents of Log.h into Main.cpp , that is, im pasting the header of the function into the main file.
- This done,the compiler will [[Compiling| compile]] each cpp file into a .obj file. But , then, in runtime, it needs to know where the declaration of Log is.
- That's what the linker does. It searches all .obj files for the Log symbol, finds its declaration and uses it when needed.
- Note: This is not done at runtime. It's a compile time operation
## Possible Linker Errors
The compiler could raise a linker error when you define the same symbol in different places. To avoid that, try to keep declarations out of .h files and try not to use the include keyword with .cpp files